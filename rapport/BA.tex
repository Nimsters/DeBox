\documentclass[a4paper]{article}

\input{Preamble}
\input{ProjectPreamble}

\title{\tit}

\begin{document}
\pagenumbering{Alph}
\begin{titlepage}
\maketitle
\thispagestyle{empty}
\end{titlepage}

\fancyfoot[]{}

\subfile{abstract.tex}

\pagebreak
\setcounter{tocdepth}{2}
\tableofcontents
\pagebreak
\lstlistoflistings
\pagebreak
\listoffigures
\clearpage
\fancyfoot[c]{Page \thepage\ of \pageref{LastBody}}
\pagenumbering{arabic}

\section{Introduction} %Remove splits into subsections
\subfile{introduction}
\clearpage

\section{Grammars}\label{grams}
To discuss and define syntaxes, we need formalism. This is provided by 
 \emph{context-free grammars}(CFGs), ``which is a recursive notation
 for describing sets of strings and imposing a structure on each such
 string''\cite[p.~39]{compilers}. This is precisely what we need, but one
 limit to their use is hinted at in the name: \emph{context-free}. Since
 ``derivation is independent of context'', a CFG \chk{definition} will not
 enforce the requirement of e.g. using the conjunction-introduction rule,
 since matching the conjunction \(\phi \land \psi\) with references to
 \(\phi\) and \(\psi\) respectively, will depend on each instance and
 what formulas \(\phi\) and \(\psi\) represent. This means that CFGs are
 limited when it comes to expressing a strict formal syntax for natural
 deduction proofs in propositional logic.

 However, we are \chk{designing} a \emph{teaching} tool, and it is thus
 paramount that we accept incorrect proofs, in order to identify mistakes
 and give proper feedback. As a consequence, we do not intend to enforce
 these context-based restrictions on neither our abstract syntax nor
 the syntax for proofs written in natural language. CFGs are thus perfectly
 suited to \chk{express} for \emph{that} purpose. Furthermore, the
 parser-generator, \yac , used to generate the source code for our parser,
 takes a ``context-free grammar specification with attached semantic
 actions''\cite[p.~44]{mosman} as its input; defining our syntax for natural language
 natural deduction using CFGs therefore means that an implementation of
 said syntax as a parser is very straigh forward.

 Hence, we use CFGs to \chk{define} our syntaxes in the following sections,
 while keeping in mind that the context restrictions of the formal syntax
 cannot be represented.

\ss{Propositional logic as a formal language}
\subfile{grammars_formal}

\ss{Grammar for proofs in natural language}\label{nlgram}
\subfile{grammars_proofs}

\section{Parsing and unparsing}\label{punp}
\subfile{parser}

\section{Validation}\label{vmod}
\ss{The validation module}
\ss{Decisions on specific implementation details}

\section{Evaluation}
\subfile{testing}

\section{Other works}

\section{Conclusions}


\label{LastBody}
\pagebreak
\pagenumbering{roman}
\fancyfoot[c]{Page \thepage\ of \pageref{LastPage}}
%\nocite{*}
\bibliographystyle{plain}
\bibliography{Bibliography}
\label{LastBio}
\clearpage
\appendix
\section*{Appendices}\label{FirstApp}
\addcontentsline{toc}{section}{Appendices}
\titlelabel{\thetitle . \quad}
\renewcommand \thesubsection{\alph{subsection}}
\renewcommand \thesubsubsection{\roman{subsubsection}}

\section{Output from \tt{Main.sml}}\label{output}
\ss{Valid proof}
\sss{Monitor output}
\codeappout{imports/valid.out}
\sss{\tt{validation\_example.txt}}
\codeappout{../validation_example.txt}

\ss{Invalid proof}
\sss{Monitor output}
\codeappout{imports/invalid.out}
\sss{\tt{validation\_example\_invalid.txt}}
\codeappout{../validation_example_invalid.txt}

\clearpage
\section{Code}\label{code}
\ss{\tt{Proof.sml}}\label{Proof}
\codeapp{../Proof.sml}

\ss{\tt{Lexer.lex}}\label{Lexer}
\codeapp{../Lexer.lex}

\ss{\tt{Parser.grm}}\label{Parser}
\codeapp{../Parser.grm}

\ss{\tt{Main.sml}}\label{Main}
\codeapp{../Main.sml}

\ss{\tt{Validation.sml}}\label{Validation.sml}
\codeapp{../Validation.sml}

\ss{\tt{Validation.sig}}\label{Validation.sig}
\codeapp{../Validation.sig}

\ss{\tt{\contentfile}}\label{\contentfile}
\codeapp{../\contentfile}

\ss{\tt{Auxiliaries.sml}}\label{Auxiliaries}
\codeapp{../Auxiliaries.sml}

\clearpage
\section{Tests}\label{tests}
\ss{\tt{\testfile}}\label{\testfile}
\codeapp{../\testfile}

\ss{Output (with command \tt{full})}\label{testout}
\codeappout{imports/unitout}

\ss{\tt{unittest\_log.txt}}\label{log}
\codeappout{../unittest_log.txt}

\clearpage
\section{Misc. code}\label{misc}
\ss{Shell script for \bp\ conversion}
\codeapp{../bpconverter}

\label{LastPage} % NB!!! LastPage label!!!
\ss{Makefile}\label{mkfile}
\codeapp{../Makefile}
\label{LastApp}
\end{document}
